name: "Gemini Runner"
description: "Generic Gemini CLI runner: installs CLI, executes a prompt with timeout, optionally publishes output."
inputs:
  gemini-api-key:
    description: "Gemini API key (e.g. secrets.GEMINI_API_KEY)."
    required: true
  timeout:
    description: "Seconds before command is terminated."
    required: false
    default: "120"
  include-output:
    description: "Append output to job summary if true."
    required: false
    default: "true"
  prompt:
    description: "Prompt passed to Gemini CLI."
    required: false
    default: "Provide a concise analysis of the context supplied by previous steps."
  prompt-file:
    description: "Optional path to a file whose contents will be used as the prompt (overrides prompt)."
    required: false
    default: ""
  output-file:
    description: "Base filename for output (timestamp will always be appended before extension)."
    required: false
    default: "gemini_output.txt"
  model:
    description: "Gemini model to use (e.g. gemini-2.5-pro, gemini-2.5-flash)."
    required: false
    default: ""
  extract-marker:
    description: "Optional text marker to extract content from (e.g. '## ðŸ¤– AI Test Review'). If set, only content from this marker onwards is returned."
    required: false
    default: ""
outputs:
  raw:
    description: "Raw Gemini CLI output."
    value: ${{ steps.run-prompt.outputs.raw }}
  file:
    description: "Final output file name (if written)."
    value: ${{ steps.run-prompt.outputs.file }}
runs:
  using: "composite"
  steps:
    - name: Install Gemini CLI
      shell: bash
      run: sudo npm install -g @google/gemini-cli@latest

    - name: Run Gemini prompt
      id: run-prompt
      shell: bash
      env:
        GEMINI_API_KEY: ${{ inputs.gemini-api-key }}
        INPUT_TIMEOUT: ${{ inputs.timeout }}
        INPUT_INCLUDE_OUTPUT: ${{ inputs.include-output }}
        INPUT_PROMPT: ${{ inputs.prompt }}
        INPUT_PROMPT_FILE: ${{ inputs.prompt-file }}
        INPUT_OUTPUT_FILE: ${{ inputs.output-file }}
        INPUT_MODEL: ${{ inputs.model }}
        INPUT_EXTRACT_MARKER: ${{ inputs.extract-marker }}
      run: |
        echo "Verifying Gemini CLI installation"
        gemini --version || echo "Gemini version check failed"

        # Check if prompt file exists
        if [ ! -f "$INPUT_PROMPT_FILE" ]; then
          echo "Error: Prompt file not found: $INPUT_PROMPT_FILE" >&2
          exit 1
        fi

        echo "Using prompt file: $INPUT_PROMPT_FILE"

        # Always append timestamp to output filename
        BASE_OUT="$INPUT_OUTPUT_FILE"
        TS=$(date +%Y%m%d%H%M%S)
        if [[ "$BASE_OUT" == *.* ]]; then
          NAME_NO_EXT="${BASE_OUT%.*}"
          EXT="${BASE_OUT##*.}"
          FINAL_OUT="${NAME_NO_EXT}-${TS}.${EXT}"
        else
          FINAL_OUT="${BASE_OUT}-${TS}"
        fi

        # Validate FINAL_OUT is set
        if [ -z "$FINAL_OUT" ]; then
          echo "Error: Failed to generate output filename" >&2
          exit 1
        fi

        echo "Output file will be: $FINAL_OUT"

        # Build gemini command arguments array
        GEMINI_ARGS=()
        if [ -n "$INPUT_MODEL" ]; then
          GEMINI_ARGS+=("-m" "$INPUT_MODEL")
          echo "Using model: $INPUT_MODEL"
        fi

        # Log prompt file info
        PROMPT_LINES=$(wc -l < "$INPUT_PROMPT_FILE" | tr -d ' ')
        PROMPT_SIZE=$(wc -c < "$INPUT_PROMPT_FILE" | tr -d ' ')
        echo "Prompt file: $INPUT_PROMPT_FILE ($PROMPT_LINES lines, $PROMPT_SIZE bytes)"

        echo "Executing prompt (timeout=$INPUT_TIMEOUT) -> $FINAL_OUT"
        
        set +e
        # Use -p flag for non-interactive mode (headless/scripting)
        # Read prompt directly from file to ensure multiline content is properly handled
        # Using $(cat ...) ensures all newlines and special characters are preserved
        timeout "$INPUT_TIMEOUT" gemini "${GEMINI_ARGS[@]}" -p "$(cat "$INPUT_PROMPT_FILE")" > "${FINAL_OUT}.raw" 2>&1
        exit_code=$?
        set -e
        
        if [ $exit_code -ne 0 ]; then
          echo "Gemini CLI exited with code $exit_code (timeout or error)."
          echo "Last 50 lines of output:"
          tail -n 50 "${FINAL_OUT}.raw" || true
        fi
        
        # Extract content from marker if specified
        if [ -n "$INPUT_EXTRACT_MARKER" ]; then
          if grep -q "$INPUT_EXTRACT_MARKER" "${FINAL_OUT}.raw"; then
            sed -n "/$INPUT_EXTRACT_MARKER/,\$p" "${FINAL_OUT}.raw" > "$FINAL_OUT"
            echo "Extracted content from marker: $INPUT_EXTRACT_MARKER"
          else
            # Fallback: use full output if marker not found
            cp "${FINAL_OUT}.raw" "$FINAL_OUT"
            echo "Warning: Could not find marker '$INPUT_EXTRACT_MARKER', using full output"
          fi
        else
          # No marker specified, use full output
          mv "${FINAL_OUT}.raw" "$FINAL_OUT"
        fi

        # Verify output file exists
        if [ ! -f "$FINAL_OUT" ]; then
          echo "Warning: Output file $FINAL_OUT was not created, creating empty file" >&2
          touch "$FINAL_OUT"
        fi

        # Export FINAL_OUT to GitHub outputs
        UNIQUE_DELIM="__GEMINI_RAW_$(date +%s%N)__"
        echo "Using unique delimiter $UNIQUE_DELIM for multi-line output"
        {
          printf 'raw<<%s\n' "$UNIQUE_DELIM"
          cat "$FINAL_OUT"
          printf '\n%s\n' "$UNIQUE_DELIM"
        } >> "$GITHUB_OUTPUT"

        echo "file=$FINAL_OUT" >> "$GITHUB_OUTPUT"
        echo "FINAL_OUT variable value: $FINAL_OUT"

        if [ "$INPUT_INCLUDE_OUTPUT" = "true" ]; then
          echo "### Gemini CLI Output ($FINAL_OUT)" >> "$GITHUB_STEP_SUMMARY"
          cat "$FINAL_OUT" >> "$GITHUB_STEP_SUMMARY"
        fi

        cat "$FINAL_OUT" || true

